package controllers

import (
	"finalyearproject/Backend/database"
	"finalyearproject/Backend/models"
	"finalyearproject/Backend/services"
	"fmt"
	"math/big"
	"time"

	"github.com/gofiber/fiber/v2"
)

// ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏ô‡∏™‡πÅ‡∏ï‡∏ô‡∏ã‡πå‡∏Ç‡∏≠‡∏á IPFSService (‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ)
var ipfsService = services.NewIPFSService()

// ‚úÖ API: ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏õ‡∏¢‡∏±‡∏á IPFS ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á CID ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á Frontend
func UploadCertificate(c *fiber.Ctx) error {
	fmt.Println("üìå UploadCertificate API called...")

	file, err := c.FormFile("file")
	if err != nil {
		fmt.Println("‚ùå No file received")
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "File not received"})
	}

	fmt.Println("‚úÖ File received:", file.Filename)

	// ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå
	src, err := file.Open()
	if err != nil {
		fmt.Println("‚ùå Failed to open file:", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to open file"})
	}
	defer src.Close()

	// ‚úÖ ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏õ‡∏¢‡∏±‡∏á IPFS ‡∏ú‡πà‡∏≤‡∏ô `ipfsService`
	cid, err := ipfsService.UploadFile(src)
	if err != nil {
		fmt.Println("‚ùå Failed to upload to IPFS:", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to upload to IPFS"})
	}

	fmt.Println("‚úÖ Uploaded file to IPFS with CID:", cid)

	// ‚úÖ ‡∏™‡πà‡∏á CID ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á Frontend
	return c.Status(fiber.StatusOK).JSON(fiber.Map{
		"message": "File uploaded successfully",
		"cid":     cid,
	})
}

func CreateCertification(c *fiber.Ctx) error {
	fmt.Println("üìå CreateCertification API called...")

	type CertRequest struct {
		EntityType       string `json:"entity_type"`
		EntityID         string `json:"entity_id"`
		CertificationCID string `json:"certification_cid"`
		IssuedDate       string `json:"issued_date"`
		ExpiryDate       string `json:"expiry_date"`
	}

	var req CertRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid request format"})
	}

	fmt.Println("üìå Received Certification Request:", req)

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤ CID
	if req.CertificationCID == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Certification CID is required"})
	}

	// ‡πÅ‡∏õ‡∏•‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å string ‚Üí time.Time
	issuedDate, err := time.Parse("2006-01-02", req.IssuedDate)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid issued date format. Use YYYY-MM-DD"})
	}

	expiryDate, err := time.Parse("2006-01-02", req.ExpiryDate)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid expiry date format. Use YYYY-MM-DD"})
	}

	// ‡πÅ‡∏õ‡∏•‡∏á time.Time ‚Üí *big.Int
	issuedDateBigInt := big.NewInt(issuedDate.Unix())
	expiryDateBigInt := big.NewInt(expiryDate.Unix())

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á eventID ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ö‡πÄ‡∏ã‡∏≠‡∏£‡πå
	eventID := fmt.Sprintf("EVENT-%s", req.EntityID)

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÉ‡∏ö‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏à‡∏≤‡∏Å Blockchain)
	existingCert, err := services.BlockchainServiceInstance.GetCertificationFromBlockchain(eventID)
	if err == nil {
		// ‡∏ñ‡πâ‡∏≤‡πÉ‡∏ö‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÄ‡∏Å‡πà‡∏≤‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏ ‚Üí ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏ó‡∏ô
		if existingCert.ExpiryDate.After(time.Now()) {
			fmt.Println("üìå Updating existing certification on Blockchain...")

			txHash, err := services.BlockchainServiceInstance.StoreCertificationOnBlockchain(
				eventID,
				req.EntityType,
				req.EntityID,
				req.CertificationCID,
				issuedDateBigInt,
				expiryDateBigInt,
			)
			if err != nil {
				return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to update certification on blockchain"})
			}

			fmt.Println("‚úÖ Certification updated on Blockchain:", txHash)
			return c.JSON(fiber.Map{
				"message":       "Certification updated successfully",
				"event_id":      eventID,
				"cid":           req.CertificationCID,
				"blockchain_tx": txHash,
			})
		}
	}

	// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏ö‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÄ‡∏Å‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ö‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÄ‡∏Å‡πà‡∏≤‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏ ‚Üí ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
	txHash, err := services.BlockchainServiceInstance.StoreCertificationOnBlockchain(
		eventID,
		req.EntityType,
		req.EntityID,
		req.CertificationCID,
		issuedDateBigInt,
		expiryDateBigInt,
	)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to store certification on blockchain"})
	}

	fmt.Println("‚úÖ Certification Event stored on Blockchain:", txHash)
	return c.Status(fiber.StatusOK).JSON(fiber.Map{
		"message":       "Certification event saved successfully",
		"event_id":      eventID,
		"cid":           req.CertificationCID,
		"blockchain_tx": txHash,
	})
}

func GetCertificationByEntity(c *fiber.Ctx) error {
	entityID := c.Params("entityID")
	if entityID == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Missing entity ID"})
	}

	// ‚úÖ ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ö‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏à‡∏≤‡∏Å Blockchain
	eventID := fmt.Sprintf("EVENT-%s", entityID)
	certification, err := services.BlockchainServiceInstance.GetCertificationFromBlockchain(eventID)
	if err != nil {
		fmt.Println("‚ùå [GetCertification] Failed to fetch from Blockchain, trying database...")
		
		// ‚úÖ ‡∏ñ‡πâ‡∏≤ Blockchain ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏•‡∏≠‡∏á‡∏î‡∏∂‡∏á‡∏à‡∏≤‡∏Å PostgreSQL
		var cert models.Certification
		if err := database.DB.Where("entity_id = ?", entityID).First(&cert).Error; err != nil {
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "No certification found"})
		}

		// ‚úÖ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ö‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏à‡∏≤‡∏Å Database ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
		return c.JSON(fiber.Map{
			"event_id":     cert.CertificationID,
			"entity_type":  cert.EntityType,
			"entity_id":    cert.EntityID,
			"cid":          cert.CertificationCID,
			"issued_date":  cert.IssuedDate.Format("2006-01-02"),
			"expiry_date":  cert.EffectiveDate.Format("2006-01-02"),
			"blockchain_tx": cert.BlockchainTxHash,
		})
	}

	// ‚úÖ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ö‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏à‡∏≤‡∏Å Blockchain ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
	return c.JSON(certification)
}

func DeleteCertification(c *fiber.Ctx) error {
	entityID := c.Params("entityID")
	if entityID == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Missing entity ID"})
	}

	eventID := fmt.Sprintf("EVENT-%s", entityID)

	// ‚úÖ Deactivate Certification ‡∏ö‡∏ô Blockchain
	txHash, err := services.BlockchainServiceInstance.DeactivateCertificationOnBlockchain(eventID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to deactivate certification on blockchain"})
	}

	fmt.Println("‚úÖ Certification deactivated on Blockchain:", txHash)
	return c.JSON(fiber.Map{
		"message":       "Certification deactivated successfully",
		"event_id":      eventID,
		"blockchain_tx": txHash,
	})
}

