func (b *BlockchainService) GetAllRawMilkTanks() ([]map[string]string, error) {
	fmt.Println("üìå Fetching all milk tanks from Blockchain...")

	// ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Smart Contract ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á tankIds ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
	tankIds, err := b.rawMilkContract.GetAllMilkTanks(&bind.CallOpts{})
	if err != nil {
		fmt.Println("‚ùå Failed to fetch milk tanks:", err)
		return nil, fmt.Errorf("‚ùå Failed to fetch milk tanks: %v", err)
	}

	var milkTanks []map[string]string

	// ‚úÖ ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πá‡∏á‡∏Å‡πå‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏≠‡∏±‡∏ô
	for _, id := range tankIds {
		tankId := common.BytesToHash(id[:]).Hex()

		// ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πá‡∏á‡∏Å‡πå‡∏à‡∏≤‡∏Å Smart Contract ‡∏ï‡∏≤‡∏° tankId
		tankIdSC, _, personInCharge, status, _, qrCodeCID, err :=
			b.rawMilkContract.GetMilkTank(&bind.CallOpts{}, id)
		if err != nil {
			fmt.Printf("‚ùå Failed to fetch details for tank %s: %v\n", tankId, err)
			continue
		}

		// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
		milkTanks = append(milkTanks, map[string]string{
			"tankId":         common.BytesToHash(tankIdSC[:]).Hex(),
			"personInCharge": personInCharge,
			"status":         fmt.Sprintf("%d", status), // ‡πÅ‡∏õ‡∏•‡∏á enum ‡πÄ‡∏õ‡πá‡∏ô string
			"qrCodeCID":      qrCodeCID,
		})
	}

	fmt.Println("‚úÖ Retrieved Milk Tanks:", milkTanks)
	return milkTanks, nil
}

func (b *BlockchainService) GetRawMilkTankDetails(tankId string) (*RawMilkData, error) {
	fmt.Println("üìå Fetching milk tank details for:", tankId)

	// ‚úÖ ‡πÅ‡∏õ‡∏•‡∏á tankId ‡πÄ‡∏õ‡πá‡∏ô bytes32
	tankIdBytes := common.HexToHash(tankId)

	// ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πá‡∏á‡∏Å‡πå‡∏à‡∏≤‡∏Å Smart Contract (‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ 6 ‡∏ï‡∏±‡∏ß)
	tankIdSC, farmWallet, personInCharge, status, qualityReportCID, qrCodeCID, err :=
		b.rawMilkContract.GetMilkTank(&bind.CallOpts{}, tankIdBytes)
	if err != nil {
		fmt.Println("‚ùå Failed to fetch milk tank details:", err)
		return nil, fmt.Errorf("‚ùå Failed to fetch milk tank details: %v", err)
	}

	// ‚úÖ ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ tankIdSC ‡πÄ‡∏õ‡πá‡∏ô string
	tankIdStr := common.BytesToHash(tankIdSC[:]).Hex()

	// ‚úÖ ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Smart Contract ‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô Go
	rawMilk := &RawMilkData{
		TankId:           tankIdStr,
		FarmWallet:       farmWallet.Hex(),
		PersonInCharge:   personInCharge,
		QualityReportCID: qualityReportCID,
		QrCodeCID:        qrCodeCID,
		Status:           uint8(status),
	}

	fmt.Println("‚úÖ Milk Tank Details Retrieved:", rawMilk)
	return rawMilk, nil
}

func (b *BlockchainService) VerifyMilkQuality(userWallet string, tankID string, approved bool, qualityReportCID string) (string, error) {
	fmt.Println("üìå Verifying milk quality for Tank:", tankID, "Approved:", approved)

	// ‚úÖ ‡∏î‡∏∂‡∏á Private Key ‡∏Ç‡∏≠‡∏á Factory (‡∏´‡∏£‡∏∑‡∏≠ User ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå)
	privateKeyHex, err := b.getPrivateKeyForAddress(userWallet)
	if err != nil {
		return "", fmt.Errorf("‚ùå Failed to get private key: %v", err)
	}

	privateKey, err := crypto.HexToECDSA(privateKeyHex)
	if err != nil {
		return "", fmt.Errorf("‚ùå Failed to parse private key: %v", err)
	}

	// ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á Transaction Auth ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Private Key
	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, getChainID())
	if err != nil {
		return "", fmt.Errorf("‚ùå Failed to create transactor: %v", err)
	}
	auth.From = common.HexToAddress(userWallet)

	// ‚úÖ ‡πÉ‡∏ä‡πâ common.BytesToHash() ‡πÅ‡∏ó‡∏ô common.HexToHash()
	tankIDBytes := common.BytesToHash([]byte(tankID))

	// ‚úÖ ‡∏™‡πà‡∏á Transaction ‡πÑ‡∏õ‡∏¢‡∏±‡∏á Smart Contract
	tx, err := b.rawMilkContract.VerifyMilkQuality(auth, tankIDBytes, approved, qualityReportCID)
	if err != nil {
		fmt.Println("‚ùå Failed to verify milk quality:", err)
		return "", err
	}

	fmt.Println("‚úÖ Transaction Sent:", tx.Hash().Hex())

	// ‚úÖ ‡∏£‡∏≠‡πÉ‡∏´‡πâ Transaction ‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
	receipt, err := bind.WaitMined(context.Background(), b.client, tx)
	if err != nil {
		fmt.Println("‚ùå Transaction not mined:", err)
		return "", err
	}

	if receipt.Status == types.ReceiptStatusFailed {
		fmt.Println("‚ùå Transaction failed!")
		return "", errors.New("Transaction failed")
	}

	fmt.Println("‚úÖ Milk quality verified on Blockchain. TX Hash:", tx.Hash().Hex())
	return tx.Hash().Hex(), nil
}

func (b *BlockchainService) UpdateMilkTankStatus(userWallet string, tankID string, approved bool) (string, error) {
	fmt.Println("üìå Updating milk tank status for Tank:", tankID, "Approved:", approved)

	// ‚úÖ ‡∏î‡∏∂‡∏á Private Key ‡∏Ç‡∏≠‡∏á Factory (‡∏´‡∏£‡∏∑‡∏≠ User ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå)
	privateKeyHex, err := b.getPrivateKeyForAddress(userWallet)
	if err != nil {
		return "", fmt.Errorf("‚ùå Failed to get private key: %v", err)
	}

	privateKey, err := crypto.HexToECDSA(privateKeyHex)
	if err != nil {
		return "", fmt.Errorf("‚ùå Failed to parse private key: %v", err)
	}

	// ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á Transaction Auth ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Private Key
	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, getChainID())
	if err != nil {
		return "", fmt.Errorf("‚ùå Failed to create transactor: %v", err)
	}
	auth.From = common.HexToAddress(userWallet)

	// ‚úÖ ‡πÉ‡∏ä‡πâ common.BytesToHash() ‡πÅ‡∏ó‡∏ô common.HexToHash()
	tankIDBytes := common.BytesToHash([]byte(tankID))

	// ‚úÖ ‡πÉ‡∏ä‡πâ VerifyMilkQuality ‡πÅ‡∏ó‡∏ô SetTankStatus
	qualityReportCID := "" // ‚úÖ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô Quality Report ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á
	tx, err := b.rawMilkContract.VerifyMilkQuality(auth, tankIDBytes, approved, qualityReportCID)
	if err != nil {
		fmt.Println("‚ùå Failed to update milk tank status:", err)
		return "", err
	}

	fmt.Println("‚úÖ Transaction Sent:", tx.Hash().Hex())

	// ‚úÖ ‡∏£‡∏≠‡πÉ‡∏´‡πâ Transaction ‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
	receipt, err := bind.WaitMined(context.Background(), b.client, tx)
	if err != nil {
		fmt.Println("‚ùå Transaction not mined:", err)
		return "", err
	}

	if receipt.Status == types.ReceiptStatusFailed {
		fmt.Println("‚ùå Transaction failed!")
		return "", errors.New("Transaction failed")
	}

	fmt.Println("‚úÖ Milk tank status updated on Blockchain. TX Hash:", tx.Hash().Hex())
	return tx.Hash().Hex(), nil
}